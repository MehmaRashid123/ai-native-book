---
sidebar_label: 'Simulating Physics in Gazebo'
# This chapter is part of Module 2: The Digital Twin (Simulation)
---

{/* Chapter Start */}

## Simulating Physics in Gazebo

Gazebo is a powerful 3D robot simulator that allows you to accurately and efficiently test your robot algorithms in a virtual environment. It provides robust physics simulation, a wide range of sensors, and convenient development tools. Building on our understanding of URDF, let's learn how to bring our robot into Gazebo and add simulated sensors.

### Spawning Your URDF into Gazebo

To simulate your robot, you first need to "spawn" it into a Gazebo world. ROS 2 provides tools to do this.

1.  **Ensure ROS 2 and Gazebo are installed:**
    If you followed the environment setup guide, you should have ROS 2. Install Gazebo by running:
    ```bash
    sudo apt install ros-humble-gazebo-ros-pkgs
    ```

2.  **Create a Gazebo Launch File:**
    Navigate to your `ros2_ws/src/py_pubsub` package (or create a new package for your robot description). Create a `launch` directory inside it if it doesn't exist, and then create a file named `spawn_robot.launch.py`:

    ```python
    import os
    from ament_index_python.packages import get_package_share_directory
    from launch import LaunchDescription
    from launch.actions import DeclareLaunchArgument
    from launch.substitutions import LaunchConfiguration, Command
    from launch_ros.actions import Node

    def generate_launch_description():
        # Get the path to your robot's URDF file
        # Assuming your URDF is in py_pubsub/urdf/simple_leg.urdf
        urdf_path = os.path.join(
            get_package_share_directory('py_pubsub'),
            'urdf',
            'simple_leg.urdf'
        )

        # Use xacro to process the URDF if you have complex macros
        # For our simple URDF, we can just read it directly
        robot_description_content = Command(['xacro ', urdf_path])
        
        # Declare a launch argument for the robot description
        rsp_arg = DeclareLaunchArgument(
            'robot_description',
            default_value=robot_description_content,
            description='URDF of the robot'
        )

        # Node for publishing the robot state
        robot_state_publisher_node = Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            parameters=[{'robot_description': robot_description_content}],
            output='screen'
        )

        # Node for spawning the robot into Gazebo
        spawn_entity_node = Node(
            package='gazebo_ros',
            executable='spawn_entity.py',
            arguments=['-entity', 'simple_leg', '-topic', 'robot_description'],
            output='screen'
        )

        # Launch Gazebo
        gazebo_server = os.path.join(get_package_share_directory('gazebo_ros'), 'launch', 'gazebo.launch.py')
        gazebo_client = os.path.join(get_package_share_directory('gazebo_ros'), 'launch', 'gzclient.launch.py')

        return LaunchDescription([
            rsp_arg,
            robot_state_publisher_node,
            spawn_entity_node,
            # If you want to launch Gazebo GUI and server from here:
            # IncludeLaunchDescription(PythonLaunchDescriptionSource(gazebo_server)),
            # IncludeLaunchDescription(PythonLaunchDescriptionSource(gazebo_client)),
        ])
    ```
    **Note:** You'll need to create a `urdf` directory inside your `py_pubsub` package and place your `simple_leg.urdf` file there.

3.  **Launch Gazebo and Your Robot:**
    First, start Gazebo (if not already running through your launch file):
    ```bash
    gazebo # Or ros2 launch gazebo_ros gazebo.launch.py
    ```
    Then, in a new terminal, source your workspace and launch your robot:
    ```bash
    cd ~/ros2_ws
    source install/setup.bash
    ros2 launch py_pubsub spawn_robot.launch.py
    ```
    Your robot should now appear in the Gazebo world.

### Adding Simulated Sensors (LiDAR/Camera)

To add sensors, you typically modify your URDF or SDF file to include sensor definitions and Gazebo plugins. These plugins tell Gazebo how to simulate the sensor data.

Here's an example of how to add a simple LiDAR sensor to a URDF link (within your `<link>` tag for the part where you want to attach the LiDAR):

```xml
    <gazebo reference="base_link"> <!-- Reference the link where the sensor is attached -->
      <sensor name="laser_sensor" type="ray">
        <pose>0 0 0.1 0 0 0</pose> <!-- Position relative to the link -->
        <visualize>true</visualize>
        <update_rate>10</update_rate>
        <ray>
          <scan>
            <horizontal>
              <samples>640</samples>
              <resolution>1</resolution>
              <min_angle>-1.57</min_angle>
              <max_angle>1.57</max_angle>
            </horizontal>
          </scan>
          <range>
            <min>0.1</min>
            <max>10.0</max>
            <resolution>0.01</resolution>
          </range>
        </ray>
        <plugin name="gazebo_ros_ray_sensor_controller" filename="libgazebo_ros_ray_sensor.so">
          <ros>
            <argument>~/out</argument>
            <remapping>~/out:=scan</remapping>
          </ros>
          <output_type>sensor_msgs/LaserScan</output_type>
          <frame_name>laser_frame</frame_name>
        </plugin>
      </sensor>
    </gazebo>
```
This snippet would be included in a `<gazebo>` tag (not `<link>`) that references the link. For cameras, you would use `type="camera"` and a `libgazebo_ros_camera.so` plugin.

### Real-Time Factor (RTF)

:::warning
**Watch Your Real-Time Factor!**

Gazebo's **Real-Time Factor (RTF)** indicates how fast the simulation is running compared to real-time. An RTF of 1.0 means the simulation is running at the same speed as the real world. If your CPU (or GPU, for complex visuals) is weak, the RTF can drop significantly below 1.0. This means the simulation is running slower than real-time, which can affect the accuracy of your sensor data and the behavior of your control algorithms. Monitor the RTF in Gazebo's status bar and consider simplifying your world or upgrading your hardware if it's consistently low.
:::

{/* Chapter End */}

:::tip
**Practice:** Try running this code in your terminal to verify it works.
:::
